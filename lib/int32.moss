import "./bool.moss" use Bool;
import "./int.moss" use Int32;
import "./ops.moss" as ops use Arg, Lhs, Rhs;
import "./wasm.moss" as wasm use I32, I64;

fn nonzero[Bool](n: I32): Bool;

fn overflow();

context Ctx = Bool, wasm::wasm, nonzero[Bool], overflow;

fn check[Ctx](z: I64): I32 {
  let w = wasm::i32_wrap_i64(z);
  if nonzero(wasm::i64_ne(wasm::i64_extend_i32_s(w), z)) {
    overflow();
  }
  w
}

fn eq[Ctx](x: I32, y: I32): Bool {
  nonzero(wasm::i32_eq(x, y))
}

fn ne[Ctx](x: I32, y: I32): Bool {
  nonzero(wasm::i32_ne(x, y))
}

fn lt[Ctx](x: I32, y: I32): Bool {
  nonzero(wasm::i32_lt_s(x, y))
}

fn gt[Ctx](x: I32, y: I32): Bool {
  nonzero(wasm::i32_gt_s(x, y))
}

fn le[Ctx](x: I32, y: I32): Bool {
  nonzero(wasm::i32_le_s(x, y))
}

fn ge[Ctx](x: I32, y: I32): Bool {
  nonzero(wasm::i32_ge_s(x, y))
}

fn neg_unchecked[Ctx](x: I32): I32 {
  wasm::i32_sub(0, x)
}

fn neg_checked[Ctx](x: I32): I32 {
  sub_checked(0, x)
}

fn add_checked[Ctx](x: I32, y: I32): I32 {
  check(wasm::i64_add(wasm::i64_extend_i32_s(x), wasm::i64_extend_i32_s(y)))
}

fn sub_checked[Ctx](x: I32, y: I32): I32 {
  check(wasm::i64_sub(wasm::i64_extend_i32_s(x), wasm::i64_extend_i32_s(y)))
}

fn mul_checked[Ctx](x: I32, y: I32): I32 {
  check(wasm::i64_mul(wasm::i64_extend_i32_s(x), wasm::i64_extend_i32_s(y)))
}

fn div_checked[Ctx](x: I32, y: I32): I32 {
  check(wasm::i64_div_s(wasm::i64_extend_i32_s(x), wasm::i64_extend_i32_s(y)))
}

fn rem_checked[Ctx](x: I32, y: I32): I32 {
  check(wasm::i64_rem_s(wasm::i64_extend_i32_s(x), wasm::i64_extend_i32_s(y)))
}

context Integers =
  Bool,
  Int32,
  ops::eq[Bool, Lhs=Int32, Rhs=Int32],
  ops::ne[Bool, Lhs=Int32, Rhs=Int32],
  ops::lt[Bool, Lhs=Int32, Rhs=Int32],
  ops::gt[Bool, Lhs=Int32, Rhs=Int32],
  ops::le[Bool, Lhs=Int32, Rhs=Int32],
  ops::ge[Bool, Lhs=Int32, Rhs=Int32],
  ops::NegOut[Arg=Int32]=Int32,
  ops::Neg[Arg=Int32],
  ops::AddOut[Lhs=Int32, Rhs=Int32]=Int32,
  ops::SubOut[Lhs=Int32, Rhs=Int32]=Int32,
  ops::MulOut[Lhs=Int32, Rhs=Int32]=Int32,
  ops::DivOut[Lhs=Int32, Rhs=Int32]=Int32,
  ops::RemOut[Lhs=Int32, Rhs=Int32]=Int32,
  ops::Add[Lhs=Int32, Rhs=Int32],
  ops::Sub[Lhs=Int32, Rhs=Int32],
  ops::Mul[Lhs=Int32, Rhs=Int32],
  ops::Div[Lhs=Int32, Rhs=Int32],
  ops::Rem[Lhs=Int32, Rhs=Int32],
;

fn int32_unchecked[Ctx](): bind Integers {
  bind
    Int32=I32,

    ops::eq[Bool, Lhs=Int32, Rhs=Int32]=eq,
    ops::ne[Bool, Lhs=Int32, Rhs=Int32]=ne,
    ops::lt[Bool, Lhs=Int32, Rhs=Int32]=lt,
    ops::gt[Bool, Lhs=Int32, Rhs=Int32]=gt,
    ops::le[Bool, Lhs=Int32, Rhs=Int32]=le,
    ops::ge[Bool, Lhs=Int32, Rhs=Int32]=ge,

    ops::NegOut[Arg=Int32]=Int32,

    ops::neg[Arg=Int32]=neg_unchecked,

    ops::AddOut[Lhs=Int32, Rhs=Int32]=Int32,
    ops::SubOut[Lhs=Int32, Rhs=Int32]=Int32,
    ops::MulOut[Lhs=Int32, Rhs=Int32]=Int32,
    ops::DivOut[Lhs=Int32, Rhs=Int32]=Int32,
    ops::RemOut[Lhs=Int32, Rhs=Int32]=Int32,

    ops::add[Lhs=Int32, Rhs=Int32]=wasm::i32_add,
    ops::sub[Lhs=Int32, Rhs=Int32]=wasm::i32_sub,
    ops::mul[Lhs=Int32, Rhs=Int32]=wasm::i32_mul,
    ops::div[Lhs=Int32, Rhs=Int32]=wasm::i32_div_s,
    ops::rem[Lhs=Int32, Rhs=Int32]=wasm::i32_rem_s,
}

fn int32_checked[Ctx](): bind Integers {
  bind
    Int32=I32,

    ops::eq[Bool, Lhs=Int32, Rhs=Int32]=eq,
    ops::ne[Bool, Lhs=Int32, Rhs=Int32]=ne,
    ops::lt[Bool, Lhs=Int32, Rhs=Int32]=lt,
    ops::gt[Bool, Lhs=Int32, Rhs=Int32]=gt,
    ops::le[Bool, Lhs=Int32, Rhs=Int32]=le,
    ops::ge[Bool, Lhs=Int32, Rhs=Int32]=ge,

    ops::NegOut[Arg=Int32]=Int32,

    ops::neg[Arg=Int32]=neg_checked,

    ops::AddOut[Lhs=Int32, Rhs=Int32]=Int32,
    ops::SubOut[Lhs=Int32, Rhs=Int32]=Int32,
    ops::MulOut[Lhs=Int32, Rhs=Int32]=Int32,
    ops::DivOut[Lhs=Int32, Rhs=Int32]=Int32,
    ops::RemOut[Lhs=Int32, Rhs=Int32]=Int32,

    ops::add[Lhs=Int32, Rhs=Int32]=add_checked,
    ops::sub[Lhs=Int32, Rhs=Int32]=sub_checked,
    ops::mul[Lhs=Int32, Rhs=Int32]=mul_checked,
    ops::div[Lhs=Int32, Rhs=Int32]=div_checked,
    ops::rem[Lhs=Int32, Rhs=Int32]=rem_checked,
}
