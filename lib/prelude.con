import "./wasip1.con" as wasi;
import "./wasm.con" as wasm use I32, offset, unreachable;

context mem[wasm::wasm, static wasm::memidx];

fn i32_load[mem, static offset](address: I32) {
  wasm::i32_load[wasm::align=2](address)
}

fn i32_store[mem, static offset](address: I32, value: I32) {
  wasm::i32_store[wasm::align=2](address, value)
}

context basic[wasi::wasip1, mem];

fn stack(): I32;

context scratch[basic, stack];

fn grow(bytes: I32);

context alloc[scratch, grow];

struct String {
  pointer: I32,
  length: I32,
}

struct Args {
  argc: I32,
  size: I32,
  argv: I32,
  buffer: I32,
}

fn Args.len(): I32 {
  self.argc
}

fn Args.get[mem](index: I32): String {
  if wasm::i32_ge_s(index, self.argc) { unreachable() }
  let pointer = i32_load[offset=0](self.argv + 4 * index);
  let next = index + 1;
  let end = if wasm::i32_lt_s(next, self.argc) {
    i32_load[offset=0](self.argv + 4 * next)
  } else {
    self.size
  };
  let length = (end - 1) - pointer; # These strings are null-terminated.
  String { pointer, length }
}

fn args[alloc](): Args {
  let pointer = stack();
  let errno = wasi::args_sizes_get(pointer, pointer + 4);
  if errno != 0 { unreachable() }
  let argc = i32_load[offset=0](pointer);
  let size = i32_load[offset=4](pointer);
  let size_argv = 4 * argc;
  let argv = pointer;
  let buffer = argv + size_argv;
  grow(size_argv + size);
  let errno = wasi::args_get(argv, buffer);
  if errno != 0 { unreachable() }
  Args { argc, size, argv, buffer }
}

fn print[scratch](str: String) {
  let pointer = stack();
  i32_store[offset=4](pointer, str.length);
  i32_store[offset=0](pointer, str.pointer);
  let errno = wasi::fd_write(1, pointer, 1, pointer + 8);
  if errno != 0 { unreachable() }
}

fn println[scratch](str: String) {
  print(str);
  print("\n");
}
