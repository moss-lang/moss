import "./bool.moss" use false, true;
import "./wasip1.moss" as wasi;
import "./wasm.moss" as wasm use I32, align, offset, unreachable;

context mem = wasm::wasm, static wasm::memidx;

fn i32_load[mem, static offset](address: I32): I32 {
  wasm::i32_load[align=2](address)
}

fn i32_load8_u[mem, static offset](address: I32): I32 {
  wasm::i32_load8_u[align=0](address)
}

fn i32_store[mem, static offset](address: I32, value: I32) {
  wasm::i32_store[align=2](address, value)
}

fn i32_store8[mem, static offset](address: I32, value: I32) {
  wasm::i32_store8[align=0](address, value)
}

context basic = false, true, wasi::wasip1, mem;

fn stack(): I32;

fn reserve(bytes: I32);

context scratch = basic, stack, reserve;

fn claim(bytes: I32);

context alloc = scratch, claim;

struct String {
  pointer: I32,
  length: I32,
}

fn String.get[mem](index: I32): I32 {
  if index >= this.length { unreachable() }
  i32_load8_u[offset=0](this.pointer + index)
}

struct Args {
  argc: I32,
  size: I32,
  argv: I32,
  buffer: I32,
}

fn Args.len(): I32 {
  this.argc
}

fn Args.get[mem](index: I32): String {
  if wasm::i32_ge_s(index, this.argc) { unreachable() }
  let pointer = i32_load[offset=0](this.argv + 4 * index);
  let next = index + 1;
  let end = if wasm::i32_lt_s(next, this.argc) {
    i32_load[offset=0](this.argv + 4 * next)
  } else {
    this.buffer + this.size
  };
  let length = (end - 1) - pointer; # These strings are null-terminated.
  String { pointer, length }
}

fn args[alloc](): Args {
  reserve(8);
  let pointer = stack();
  let errno = wasi::args_sizes_get(pointer, pointer + 4);
  if errno != 0 { unreachable() }
  let argc = i32_load[offset=0](pointer);
  let size = i32_load[offset=4](pointer);
  let size_argv = 4 * argc;
  let argv = pointer;
  let buffer = argv + size_argv;
  reserve(size_argv + size);
  claim(size_argv + size);
  let errno = wasi::args_get(argv, buffer);
  if errno != 0 { unreachable() }
  Args { argc, size, argv, buffer }
}

fn read[alloc](path: String): String {
  reserve(4);
  let pointer = stack();
  let fd = 3;
  let dirflags = 0;
  let oflags = 0;
  let fs_rights_base = wasm::i64_extend_i32_u(0);
  let fs_rights_inheriting = wasm::i64_extend_i32_u(0);
  let fdflags = 0;
  let errno = wasi::path_open(
    fd,
    dirflags,
    path.pointer,
    path.length,
    oflags,
    fs_rights_base,
    fs_rights_inheriting,
    fdflags,
    pointer,
  );
  if errno != 0 { unreachable() }
  let fd = i32_load[offset=0](pointer);
  var length = 0;
  var more = true;
  while more {
    let chunk = 65536;
    reserve(length + chunk + 12);
    let iovs = pointer + length + chunk;
    i32_store[offset=0](iovs, pointer + length);
    i32_store[offset=4](iovs, chunk);
    let errno = wasi::fd_read(fd, iovs, 1, iovs + 8);
    if errno != 0 { unreachable() }
    let size = i32_load[offset=8](iovs);
    length = length + size;
    if size != chunk {
      more = false;
    }
  }
  let errno = wasi::fd_close(fd);
  if errno != 0 { unreachable() }
  claim(length);
  String { pointer, length }
}

fn print[scratch](str: String) {
  reserve(12);
  let pointer = stack();
  i32_store[offset=0](pointer, str.pointer);
  i32_store[offset=4](pointer, str.length);
  let errno = wasi::fd_write(1, pointer, 1, pointer + 8);
  if errno != 0 { unreachable() }
  let size = i32_load[offset=8](pointer);
  if size != str.length { unreachable() }
}

fn println[scratch](str: String) {
  print(str);
  print("\n");
}

fn string_to_uint[mem](str: String): I32 {
  var n = 0;
  var i = 0;
  while i < str.length {
    n = n * 10 + i32_load8_u[offset=0](str.pointer + i) - 48;
    i = i + 1;
  }
  n
}

fn uint_to_string[alloc](n: I32): String {
  let max = 10;
  reserve(max);
  let start = stack();
  var value = n;
  var index = max - 1;
  var writing = true;
  while writing {
    let digit = wasm::i32_rem_u(value, 10);
    i32_store8[offset=0](start + index, digit + 48);
    value = wasm::i32_div_u(value, 10);
    if value == 0 {
      writing = false;
    } else {
      index = index - 1;
    }
  }
  claim(max);
  let length = max - index;
  let pointer = start + index;
  String { pointer, length }
}
